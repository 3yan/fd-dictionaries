#!/usr/bin/perl

# Convert result of a Postgresql query of a 'Woordenboek' table extended by a
# 'language' column from STDIN (or @ARGV) into TEI format on STDOUT

# This only emits <entry> elements.  The TEI header and footer have to be
# provided extra.

# This script differs from ergane2tei.pl by Horst Eyermann in that it
# understands a different input.  ergane2tei.pl's input seems had been
# generated by Ergane 5.0's export function which is not included in the
# current version 8.0 from http://download.travlang.com (at least I have not
# found it).  The website of version 5 is still available at
# http://download.travlang.com/Ergane/download-en.html, but the files not.

use warnings;
use strict;

sub in_array
{
  my($arrayref, $what) = @_;
  local $_;
  foreach (@$arrayref)
  { return 1 if $_ eq $what }
  return 0
}

sub xmlEscape
{
  my $s = shift;
  $s =~ s/&/&amp;/g;
  $s =~ s/\"/&quot;/g;
  $s =~ s/\'/&apos;/g;
  $s =~ s/</&lt;/g;
  $s
}

# For the hash values see also The FreeDict HOWTO, Table 5.1. Part of Speech
# Typology.
my %t2p =
(
  0 => 'n', # Nomen
  1 => 'v', # Verb
  2 => 'adv', # Adverb
  3 => 'v', # Verb (what is the difference to 1? transitive/intransitive?)
#  4 => 'v', # Numeral
  10 => 'pron', # Pronoun
  23 => 'n', # Nomen Proprium
  # vt vi vti adj conj prep interj pron art num
);

sub Type2Pos
{
  my $Type = shift;
  return $t2p{$Type} if exists $t2p{$Type};
  return undef
}

my %TypesCount;

sub formatEntry
{
  my($XEntry, $Type, @senses) = @_;
  my $senses = '';
  foreach (@senses)
  {
    my @transs = ();
    foreach my $trans1 (@{$$_{'transs'}})
    {
      $trans1 =~ s/\s+$//;
      my $trans = "    <trans><tr>" . xmlEscape($trans1)
        . "</tr></trans>\n";
      push @transs, $trans unless in_array \@transs, $trans
    }
    $senses .= "  <sense>\n" . join('', @transs) ."  </sense>\n"
  }
  my $orth = xmlEscape($XEntry);
  $TypesCount{$Type}++;
  my $pos = Type2Pos($Type);
  print STDERR "Line $.: Unknown Type $Type ('$XEntry')"
    unless defined $pos || $TypesCount{$Type}>1;
  my $gramGrp = (defined $pos) ?
    "\n<gramGrp><pos>$pos</pos></gramGrp>" : '';
  print <<"END";
<entry>
  <form><orth>$orth</orth></form>$gramGrp
$senses</entry>
END
}

my($XEntry, $Type, %currentSense, @senses);
while(<>)
{
  # get all the columns
  # "SELECT *" gave us too much
  # we only use $wEspKey
  my($wKeyNo, $wEspKey, $wXEntry, $wType, $wGType, $wFType, $wOmschr, $wFreq,
    $wVolgorde, $wOpm, $wOpm2, $wSortKey, $wUitspraak, $wlanguage, $xKeyNo,
    $xEspKey, $xXEntry, $xType, $xGType, $xFType, $xOmschr, $xFreq, $xVolgorde,
    $xOpm, $xOpm2, $xSortKey, $xUitspraak, $xlanguage) = split /\t/;
  unless(defined $wXEntry && defined $xXEntry)
  {
    print STDERR "Line $.: Empty headword or trans. Skipping: '",
      quotemeta $_, "'\n";
    next
  }
  $wXEntry =~ s/\s+$//;# mdb-sql exports with lots of trailing space
  $xXEntry =~ s/\s+$//;
  #print STDERR "Line $.: wXEntry='$wXEntry' xXEntry='$xXEntry'\n";
  # collect <orth>, <pron>, <tr>s by <trans> and <sense>s
  if(undef $XEntry || $wXEntry ne $XEntry || $wType ne $Type)
  {
    if(defined $XEntry)
    {
      push @senses, { %currentSense };
      # output an <entry>
      formatEntry($XEntry, $Type, @senses);
    }
    # collect line for a new <entry>
    $XEntry = $wXEntry;
    $Type = $wType;
    @senses = ();
    $currentSense{'EspKey'} = $wEspKey;
    $currentSense{'transs'} = [ $xXEntry ]
  }
  else
  {
    if($currentSense{'EspKey'} == $wEspKey)
    {
      # add <trans> to current <sense>
      push @{ $currentSense{'transs'} }, $xXEntry
    }
    else
    {
      # start a new <sense>
      push @senses, { %currentSense };
      $currentSense{'EspKey'} = $wEspKey;
      $currentSense{'transs'} = [ $xXEntry ]
    }
  }
}

# output last <entry>
push @senses, { %currentSense };
formatEntry($XEntry, $Type, @senses);

# Output $Type statistics
print STDERR "Type\tCount\n----------------\n";
foreach (sort keys %TypesCount)
{ print STDERR "$_\t", $TypesCount{$_}, "\n" }

