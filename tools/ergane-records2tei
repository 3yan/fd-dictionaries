#!/usr/bin/perl

# Convert result of a Postgresql query of a 'Woordenboek' table extended by a
# 'language' column from STDIN (or @ARGV) into TEI format on STDOUT

# This only emits <entry> elements.  The TEI header and footer have to be
# provided extra.

# This script differs from ergane2tei.pl by Horst Eyermann in that it
# understands a different input.  ergane2tei.pl's input seems had been
# generated by Ergane 5.0's export function which is not included in the
# current version 8.0 from http://download.travlang.com (at least I have not
# found it).  The website of version 5 is still available at
# http://download.travlang.com/Ergane/download-en.html, but the files not.

use warnings;
use strict;

sub in_array
{
  my($arrayref, $what) = @_;
  local $_;
  foreach (@$arrayref)
  { return 1 if $_ eq $what }
  return 0
}

sub xmlEscape
{
  my $s = shift;
  $s =~ s/&/&amp;/g;
  $s =~ s/\"/&quot;/g;
  $s =~ s/\'/&apos;/g;
  $s =~ s/</&lt;/g;
  $s
}

# For the hash values see also The FreeDict HOWTO, Table 5.1. Part of Speech
# Typology.  The Ergane typology is more fine grained.
my %t2p =
(
  0 => 'n', # Nomen
  1 => 'adj', # Adjective
  2 => 'adv', # Adverb
  3 => 'v', # Verb
  4 => 'num', # Numeral
  5 => 'prep', # Preposition
  6 => 'int', # Interjection
  7 => 'pron', # Relative Pronoun
  8 => 'conj', # Conjunction
  10 => 'pron', # Pronoun
  11 => 'art', # Article
  12 => 'pron', # Personal Pronoun
  13 => 'pron', # Demonstrative Pronoun
  14 => 'pron', # Indefinite Pronoun
  15 => 'pron', # Reflexive Pronoun
  16 => 'pron', # Possesive Pronoun
  17 => 'num', # Ordinal Number
  20 => 'pron', # Interrogative Pronoun
  23 => 'n', # Nomen Proprium
);

sub posType2Pos
{
  my $Type = shift;
  return $t2p{$Type} if exists $t2p{$Type};
  return undef
}

sub genType2Gen
{
  my $Type = lc shift;# assume case doesn't matter (dut.mdb contains M F N)
  return $Type if $Type eq 'm' or $Type eq 'f' or $Type eq 'n';
  return undef
}

my (%POSTypesCount, %genTypesCount);

sub formatEntry
{
  my($XEntry, $POSType, $genType, @senses) = @_;
  my $senses = '';
  foreach (@senses)
  {
    my @transs = ();
    foreach my $trans1 (@{$$_{'transs'}})
    {
      $trans1 =~ s/\s+$//;
      my $trans = "    <trans><tr>" . xmlEscape($trans1)
        . "</tr></trans>\n";
      push @transs, $trans unless in_array \@transs, $trans
    }
    $senses .= "  <sense>\n" . join('', @transs) ."  </sense>\n"
  }
  my $orth = xmlEscape $XEntry;
  $POSTypesCount{$POSType}++;
  $genTypesCount{$genType}++;
  my $pos = posType2Pos $POSType;
  my $gen = genType2Gen $genType;
  print STDERR "Line $.: Unknown Part-of-Speech type $POSType ('$XEntry')\n"
    unless defined $pos || $POSTypesCount{$POSType}>1;
  print STDERR "Line $.: Unknown Genus type $genType ('$XEntry')\n"
    unless defined $gen || $genTypesCount{$genType}>1;
  my $gramGrp = '';
  if (defined($pos) or defined($gen))
  {
    $gramGrp = "\n  <gramGrp>";
    $gramGrp .= "<pos>$pos</pos>" if defined $pos;
    $gramGrp .= "<gen>$gen</gen>" if defined $gen;
    $gramGrp .= "</gramGrp>"
  }
  print <<"END";
<entry>
  <form><orth>$orth</orth></form>$gramGrp
$senses</entry>
END
}

my($XEntry, $POSType, $genType, %currentSense, @senses);
while(<>)
{
  # get all the columns
  # "SELECT *" gave us too much
  # we only use $wEspKey
  my($wKeyNo, $wEspKey, $wXEntry, $wType, $wGType, $wFType, $wOmschr, $wFreq,
    $wVolgorde, $wOpm, $wOpm2, $wSortKey, $wUitspraak, $wlanguage, $xKeyNo,
    $xEspKey, $xXEntry, $xType, $xGType, $xFType, $xOmschr, $xFreq, $xVolgorde,
    $xOpm, $xOpm2, $xSortKey, $xUitspraak, $xlanguage) = split /\t/;
  unless(defined $wXEntry && defined $xXEntry)
  {
    print STDERR "Line $.: Empty headword or trans. Skipping: '",
      quotemeta $_, "'\n";
    next
  }
  $wXEntry =~ s/\s+$//;# mdb-sql exports with lots of trailing space
  $xXEntry =~ s/\s+$//;
  $wGType =~ s/\s+$//;
  #print STDERR "Line $.: wXEntry='$wXEntry' xXEntry='$xXEntry'\n";
  # collect <orth>, <pron>, <tr>s by <trans> and <sense>s
  if(not(defined($XEntry)) || $wXEntry ne $XEntry
			   || $wType ne $POSType
			   || $wGType ne $genType)
  {
    if(defined $XEntry)
    {
      push @senses, { %currentSense };
      # output an <entry>
      formatEntry $XEntry, $POSType, $genType, @senses
    }
    # collect line for a new <entry>
    $XEntry = $wXEntry;
    $POSType = $wType;
    $genType = $wGType;
    @senses = ();
    $currentSense{'EspKey'} = $wEspKey;
    $currentSense{'transs'} = [ $xXEntry ]
  }
  else
  {
    if($currentSense{'EspKey'} == $wEspKey)
    {
      # add <trans> to current <sense>
      push @{ $currentSense{'transs'} }, $xXEntry
    }
    else
    {
      # start a new <sense>
      push @senses, { %currentSense };
      $currentSense{'EspKey'} = $wEspKey;
      $currentSense{'transs'} = [ $xXEntry ]
    }
  }
}

# output last <entry>
push @senses, { %currentSense };
formatEntry $XEntry, $POSType, $genType, @senses;

# Output $POSType and $genType statistics
print STDERR "POSType\tCount\tName\n----------------------\n";
foreach (sort keys %POSTypesCount)
{ print STDERR "$_\t", $POSTypesCount{$_}, "\t", $t2p{$_} || 'unknown', "\n" }

print STDERR "genType\tCount\n------------------\n";
foreach (sort keys %genTypesCount)
{ print STDERR "$_\t", $genTypesCount{$_}, "\n" }

